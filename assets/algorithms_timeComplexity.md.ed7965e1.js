import{_ as t,c as e,o as n,a as r}from"./app.302b7c71.js";const m=JSON.parse('{"title":"时间复杂度","description":"","frontmatter":{},"headers":[{"level":2,"title":"常见的时间复杂度","slug":"常见的时间复杂度","link":"#常见的时间复杂度","children":[]}],"relativePath":"algorithms/timeComplexity.md"}'),o={name:"algorithms/timeComplexity.md"},s=r('<h1 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-hidden="true">#</a></h1><p>时间复杂度是一个函数，它定量描述了该算法的运行时间。这是一个大概的计算，它可以是一个大概的计算，也可以是一个精确的计算。</p><p>时间复杂度通常用大 O 符号表示，它描述了算法运行时间与输入数据之间的关系。</p><h2 id="常见的时间复杂度" tabindex="-1">常见的时间复杂度 <a class="header-anchor" href="#常见的时间复杂度" aria-hidden="true">#</a></h2><p><strong>O(1)</strong>：常数时间复杂度。无论输入数据的大小如何，执行时间都保持不变。例如，访问数组的元素。</p><p><strong>O(n)</strong>：线性时间复杂度。执行时间与输入数据的大小成正比。例如，遍历一个数组。</p><p><strong>O(log n)</strong>：对数时间复杂度。每一步都可以将问题规模减小一半。例如，二分查找。</p><p><strong>O(n log n)</strong>：线性对数时间复杂度。例如，快速排序、归并排序。</p><p><strong>O(n^2)</strong>：平方时间复杂度。例如，冒泡排序、插入排序。</p><p><strong>O(2^n)</strong>：指数时间复杂度。例如，计算斐波那契数列的递归实现。</p><p><strong>O(n!)</strong>：阶乘时间复杂度。例如，旅行商问题的暴力解决方案。</p><p>在选择算法时，我们通常希望时间复杂度尽可能低，因为这意味着算法可以更快地运行。然而，低时间复杂度的算法可能需要更复杂的编程，或者可能需要更多的计算资源。因此，选择哪种算法通常需要在执行速度、编程复杂性和资源使用之间进行权衡。</p>',12),a=[s];function p(i,_,c,d,l,g){return n(),e("div",null,a)}const f=t(o,[["render",p]]);export{m as __pageData,f as default};
