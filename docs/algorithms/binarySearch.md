# 二分查找法

前提：数组且有序

```js
/**
 * 思路：
 * 定义一函数，把数组和目标元素当作参数传入
 * 函数最初先判断数组是否为空，为空就直接返回-1
 * 定义一变量保存最后位置值，初始值为数组长度
 * 定义一变量保存最初位置值，初始值为0
 * 执行while循环，只要最初位置值小于或等于最后位置值就继续遍历
 * 在遍历阶段内部
 * 定义一变量保存数组的中间元素值
 * 定义一变量保存中间元素值的下标索引值
 * 拿目标元素和中间元素做比较
 * 如果目标元素小于中间元素，说明目标元素在中间元素的左边，那边把中间元素的上一个元素的索引值作为最后位置值，执行下一轮遍历
 * 如果目标元素大于中间元素，说明目标元素在中间元素的右边，那边把中间元素的下一个元素的索引值作为最初位置值，执行下一轮遍历
 * 如果目标元素等于中间元素，说明找到了，那么返回中间元素的索引值，结束遍历
 * 遍历结束后，如果还没找到，则返回-1
 */

var arr = [1,2,3,4,5,6,12,32,34,55,78,110]

function binarySearch(arr, target){
  // 如果数组为空，直接返回-1
  if(arr.length === 0) return -1
  // 获取数组长度，作为遍历查询的最后位置值
  var h = arr.length-1
  // 定义遍历查询的最初位置值为0
  var l = 0
  // 只要没遍历到最后位置，就继续遍历
  while(l<=h){
    // 获取数组中间元素的索引
    var i = Math.floor((h+l/2))
    // 获取数组中间元素
    var m = arr[i]
    if(target < m){
      // 如果目标元素比中间元素小，说明目标元素一定在中间元素左边，就把中间元素的前一位元素的索引值作为下一轮遍历的最后位置值，开始下一轮遍历
      h = i-1
    }else if(target > m){
      // 如果目标元素比中间元素大，说明目标元素一定在中间元素右边，就把中间元素的下一位元素的索引值作为下一轮遍历的最初位置值，开始下一轮遍历
      l = i+1
    }else{
      // 目标元素与中间元素相等，则返回中间元素索引值，结束遍历
      return i
    }
  }
  // 如果数组完全遍历一遍都没找到，返回-1
  return -1
}

console.log(binarySearch(arr, 55)) // => 9
console.log(binarySearch(arr, 555)) // => -1
```
